#include <stdio.h>
#include <stdbool.h>

//2.58
/****************************************************************************/
bool is_little_endian(void){
    int val = 0x0011;
    unsigned char *p =(unsigned char *) &val;
    if(*p){
        return 1;
    }
    return false;
}
/****************************************************************************/

//2.60
/****************************************************************************/
unsigned replace_byte(unsigned x, int i, unsigned char b){
    // printf("0x%.8x\n", ~(0xff << (8*i)));
    // printf("0x%.8x\n", (x & ~(0xff << (8*i))));
    // printf("0x%.8x\n", (b << (8*i)));
    return (x & ~(0xff << (i << 3))) | (b << (i << 3));
}
/****************************************************************************/

//2,62
/****************************************************************************/
//判断是否为算数右移
bool int_shifts_are_arithmetic(void){
    int x = ~0;
    return x >> 1 == x;
}
/****************************************************************************/

//2.63
/****************************************************************************/
unsigned srl(unsigned x, int k){
    unsigned xsra = (int) x >> k;

    unsigned mask = (0x1 << k) - 1;
    // printf("0x%.8x\n", mask);
    unsigned w =  sizeof(int) << 3;
    mask = ~(mask << (w - k));
    // printf("0x%.8x\t 0x%.8x\n", xsra, mask);
    return mask & xsra;
}

unsigned sra(int x , int k){
    int xsrl = (unsigned) x >> k;

    unsigned w = sizeof(int) << 3;
    //symbol == 0 -> x为正
    unsigned symbol = (0x1 << (w - k - 1)) & xsrl;
    unsigned mask = ~(symbol - 1);
    // printf("0x%.8x\t 0x%.8x\t 0x%.8x\n", xsrl, symbol, mask);
    return mask | xsrl;
}
/****************************************************************************/

//2.64
/****************************************************************************/
int any_unsigned_odd_one(unsigned x){
    //assum w=32
    unsigned mask = 0xaaaaaaaa;
    return !!(x & mask);
}
/****************************************************************************/

//2.65
/****************************************************************************/
// 将x的高位字节与低位字节异或，对应的位共有三种情况：都为0、都为1、一个为0一个为1
// 都为0可以不用管。
// 都为1，表示高低位的对应位置都为1，则有偶数个1，按题目要求直接为0，也可以不管
// 一个为0一个为1，表示高低位对应位置不全为1，则表示有奇数个1，需要计算奇数个1的个数，若有偶数个奇数1，则返回0，否则返回1
// 只需要再将结果二分，重复上述过程即可
int odd_ones(unsigned x){
    x = x ^ (x >> 16);  
    x = x ^ (x >> 8);
    x = x ^ (x >> 4);
    x = x ^ (x >> 2);
    x = x ^ (x >> 1);

    return x & 1;
}
/****************************************************************************/

int main()
{
    int x = 0x89abdcef;
    int y = 0x76543210;

    if(is_little_endian()){
        printf("is little endian\n");  
    }else{
        printf("is big endian\n");
    }

    //2.59
    /****************************************************************************/
    printf("0x%.8x\n", (x & 0xff) | (y & ~0xff));
    /****************************************************************************/

    //2.60
    /****************************************************************************/
    printf("replacd-->0x%.8x\n", replace_byte(0x12345678, 2, 0xab));
    printf("replace-->0x%.8x\n", replace_byte(0x12345678, 0, 0xab));
    /****************************************************************************/

    //2.61
    /****************************************************************************/
    x = 0xffffffff;
    y = 0xff0000ff;
    // !(~x)
    printf("0x%.8x\t 0x%.8x\n", !(~x), !(~y));

    x = 0x00000000;
    y = 0x00fb42ac;
    // !x
    printf("0x%.8x\t 0x%.8x\n", !x, !y);

    x = 0x123456ff;
    y = 0x12345678;
    // !(~x << ((sizeof(int) - 1) << 3))
    printf("0x%.8x\t 0x%.8x\n", !(~x << ((sizeof(int) - 1) << 3)), !(~y << (sizeof(int) - 1)<< 3));

    x = 0xff123456;
    y = 0x81123456;
    // !(~x >> ((sizeof(int) - 1) << 3))
    printf("0x%.8x\t 0x%.8x\n", !(~x >> ((sizeof(int) - 1) << 3)), !(~y >> ((sizeof(int) - 1) << 3)));

    x = 0x00123456;
    y = 0x19123456;
    printf("0x%.8x\t 0x%.8x\n", !(x >> ((sizeof(int) - 1) << 3)), !(y >> ((sizeof(int) - 1) << 3)));
    /****************************************************************************/

    //2.62
    /****************************************************************************/
    //若x右移4位得到0xf8000000,则证明为算数右移
    x = 0x80000000, y = 0x70000000;
    printf("0x%.8x >> 4 --> 0x%.8x\n", x, x >> 4);
    printf("0x%.8x >> 4 --> 0x%.8x\n", y, y >> 4);

    if(int_shifts_are_arithmetic()){
        printf("int shifts are arithemtic\n");
    }else{
        printf("int shifts are logic\n");
    }
    /****************************************************************************/

    //2.63
    /****************************************************************************/
    printf("0x%.8x\t srl(4) =  0x%.8x\n", 0x70000008, srl(0x70000008, 4));
    printf("0x%.8x\t srl(4) =  0x%.8x\n", 0x80000100, srl(0x80000100, 4));
    printf("0x%.8x\t sra(4) =  0x%.8x\n", 0x70000008, sra(0x70000008, 4));
    printf("0x%.8x\t sra(4) =  0x%.8x\n", 0x80000100, sra(0x80000100, 4));
    /****************************************************************************/

    //2.64
    /****************************************************************************/
    printf("0x01 - %d\t 0x02 - %d\n", any_unsigned_odd_one(0x01), any_unsigned_odd_one(0x2));
    /****************************************************************************/

    //2.65
    /****************************************************************************/
    printf("0xf070 - %d\t 0xf0f0 - %d\n", odd_ones(0xf070), odd_ones(0xf0f0));
    /****************************************************************************/

    return 0;
}

// 1 2 3 4
// 1 2 3 4 5

// 2-1 1-3 3-2
// 2-0 1-2 3-1 0-5
// 3-1 1-4 4-2 2-5